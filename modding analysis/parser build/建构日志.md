测试了 Element 对指针删除时的控制权，当 get() 在无论何时何地被调用后，delete Element* 后，不会释放值的内存，因为已将控制权赋予别处的指针。测试良好。5.31 - 3:21

sstream清空缓存必须调用 .str("")，也有的地方说要先调用 .clear()，总之只调用后者并不能清空缓存。

测试了英文下的 非引用字符串、标识符、引用字符串（可以包含注释标记 # ）、行内任意位置开始注释的一般情况。特殊情况下，引用字符串没有结束引号，读取到行末结束，但应额外补齐一个引号。还缺少一个特殊情况处理：转义引用字符。

增加了对上述两种特殊情况的处理。5.31 - 3:57



指针的指针可以将后者指向的前者设置为空，这样在最终delete前者时就是在delete空指针，不会造成内存泄漏。



无结束符的解析分支不会拿取当前的元素，而希望保留给下一个解析树用。因此加上了对当前指向元素的指针是否位空的判断，因为如果解析树拿去了当前元素，无论时下列情况的哪一种，都会获取或移交对值的控制权后，删除并置空当前元素指针。

> + 拿取值并暂存值树的新 Volume 对象里，传递元素指针到新 Volume 对象里时，后者自行获取对值的控制权，然后删除并指控前者。此时尚未构建新的 Token。
> + 构建新的 Token，通过任意类型的 Token 构造函数将树的 Volume 指针传递给 Token，后者自行获取对值的控制权，然后删除并置空前者
> + 已构建树的 Token 对象，通过某些类型 Token 的 Append 函数将元素指针传递给前者，前者自行获取对值的控制权，然后删除并置空后者。
> + 当前元素造成异常而构建失败，~~此时调用树的 fail_to_build 方法，~~由于元素对象尚未失去对值的控制权，因此可以直接删除其指针并置空。至于已经通过树移交过控制权的值，当调用树的析构函数时，会分别在尚未传递给 Token 的 Volume 对象里，或已构建的 Token 对象里做销毁处理。



删除了 Token 基类的 fr，因为所构建的 Token 毫无记录 from-Token 的tok值的必要，因为Tokenizer 是按照文本逐字读取的，不存在追加了本不应该属于的子 Token，除非是语法错误，比如少写了一个右大括号，但即使这样多一个对 from-Token 是否一致的判断也不能排除此错误，因为这是语法规则决定的。6.1 - 5:02
